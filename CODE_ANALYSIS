WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd) {
    HANDLE hKey = 65Ch; // (uExitCode) Line 405473
    DWORD dwMilliseconds = 0x03E8 // Time = 1000 msec -- Line 405479

    // This is called to buy the malware time to perform some time-consuming conditional checks
    Sleep(dwMilliseconds); // CALL Sleep() for 1000 msec = 1 sec -- Line 40547E

    // CALL
    sub_4014B0();
    /**
        It will first employ its Anti analysis, Anti Sandbox and
        Anti Virtualization checks.
    */
        //// CALL
        sub_401000(); // CHECK IF IN A SANDBOX (ANTI-VM CHECK)
            /**
                OBSERVATIONS: String "qemu" is a local function variable.
                QEMU is an open-source virtualization OS emulator.

                CLAIM 1: the two other local variables next to it (unk_407448, and unk_407450)
                are strings "vmware", "virtual", "xen" or similar string names for virtual machine tools.
                We can infer that the malware is checking artifacts see if it is running
                inside a virtual machine. This is evident from the fact that at this point it has
                attempted to read the primary hard disk to perform a sequential scan on
                specified strings--one of which, as stated, is "qemu".

            */
            //// CALL
            CreateFileA(); // using the following parameters
            /**
                dwCreationDisposition = 3 ==> OPEN EXISTING FILE
                dwDesiredAccess = 0 ==> Allows the application to query device attributes without accessing a device
                FileName = \\\\.\\PhysicalDrive0 ==> Opens the first physical drive. Hard Disk Numbers Start at 0.

                NOTE: Windows Server 2003 and Windows XP:  Direct access to the
                disk or to a volume is not restricted in this manner.
                You can use the CreateFile function to open a physical disk
                drive or a volume, which returns a direct access storage device (DASD)
                handle that can be used with the DeviceIoControl function. This enables you
                to access the disk or volume directly, for example such disk metadata as
                the partition table.
            */
            //// CALL function
            DeviceIoControl(); // using the following parameter -- Line 4010EA
                    /**
                        dwIoControlCode = 0x002D1400 ==> IOCTL_STORAGE_QUERY_PROPERTY

                        IO Control Code Reference (See SOURCES CITED #2 Below):

                        FROM MSDN:
                        Windows applications can use this control code to return
                        the properties of a storage device or adapter. The request
                        indicates the kind of information to retrieve, such as the
                        inquiry data for a device or the capabilities and limitations
                        of an adapter. IOCTL_STORAGE_QUERY_PROPERTY CAN ALSO BE USED
                        TO DETERMINE WHETHER THE PORT DRIVER SUPPORTS A PARTICULAR
                        PROPERY OR WHICH FIELDS IN THE PROPERTY DESCRIPTOR CAN BE
                        MODIFIED WITH A CHANGE PROPERTY REQUEST.
                    */

    } //// RETURN FROM sub_4014B0();

    //// CALL
    sub_401220() { // CHECKING FOR BLACKLISTED PROCESSES
        //// CALL to
        sub_4031F0(); // --> CreateToolhelp32Snapshot with the following parameters:
            //// CALL to
            CreateToolhelp32Snapshot();
            /**
                CreateToolhelp32Snapshot Takes a snapshot of the specified processes,
                as well as the heaps, modules, and threads used by these processes.

                dwFlags = 0x0000000F ==> (TH32CS_SNAPALL -- SEE SOURCES CITED LIST #5)
                Includes all processes and threads in the system, plus the heaps and
                modules of the process specified in th32ProcessID.
                Equivalent to specifying the TH32CS_SNAPHEAPLIST, TH32CS_SNAPMODULE,
                TH32CS_SNAPPROCESS, and TH32CS_SNAPTHREAD values combined using an OR operation ('|').

                th32ProcessID = 0 ==>
                The process identifier of the process to be included in the snapshot.
                This parameter can be zero to indicate the current process.
                This parameter is used when the TH32CS_SNAPHEAPLIST, TH32CS_SNAPMODULE, T
                H32CS_SNAPMODULE32, or TH32CS_SNAPALL value is specified. Otherwise,
                it is ignored and all processes are included in the snapshot.

                NOTE: Process discovery: Malware may be able to detect whether
                there are any running processes related to a sandbox. For example,
                processes such as VmwareService.exe can be easily detected with the
                CreateToolHelp32Snapshot API, to get a snapshot of the current
                running processes, and then list each process of the snapshot with
                the APIs Process32First and Process32Next.

                This is where the malware is checking for blacklisted processes. Specifically,
                this malware looks for the existence of the following executables:

                "WUAUCLT.EXE" --
                    The wuauclt.exe file is located in the folder C:\Windows\System32
                    It Automatically checks with the Microsoft website for updates to the
                    OS. It shows up on the Task Manager's processes list when it is waiting
                    for a response, such as to confirm permission to download an update.

                "MSSECES.EXE" --
                    Msseces.exe is the process used to run the graphical user interface
                    of (MSE) Microsoft Security Essentials.  Without this process, you
                    wouldn’t be able to adjust any of the settings in MSE, and you wouldn’t
                    be able to see alerts from new malware threats.  If you take a look at
                    this process in Task Manager, you’ll see the relative description of
                    what this process does. It is part of Microsoft's Antivirus software suite.
                    It provides pop-up alerts if Microsoft Security Essentials finds an issue.

                "MSACUI.EXE" --
                    This file is located in the folder C:\Program Files\Windows Defender\
                    and is a component of the Windows Defender Anti-spyware feature from
                    Microsoft.

                "MRT.EXE" --
                    Mrt.exe is the main executable used to run the Microsoft Removal Tool.
                    It is not a core Windows process. The Microsoft Removal Tool was first
                    released in 2005 for the Microsoft Windows operating system. It is a
                    freely available tool and it scans your computer for some of the most
                    common infections. If you turn on Automatic Updates in Windows, this
                    tool will be downloaded and run on the second Tuesday of each month.
                    It runs silently in the background unless it finds an infection.

                "RSTRUI.EXE" --
                    System Restore is a recovery tool developed by Microsoft that allows
                    users to revert their computer's state such as the registry and system
                    files to a previous point in time. Introduced with Windows ME, System
                    Restore is not made part of all Windows operating systems released ever
                    since excluding Windows Server. System Restore allows users to change
                    the System Restore configuration, roll back to an existing restore point
                    or create a new restore point manually.
            */
                //// CALL
                Process32First(); // which Retrieves information about the first process encountered in a system snapshot.
                    //// LOOP CALL
                    Process32Next(); // which Retrieves information about the next process recorded in a system snapshot.

    } // RETURN FROM sub_401220



    //// CALL
    sub_401260() { // CHECK FOR ANTI-SANDBOX BLACKLISTED DLLs
        ////CALL TO
        GetModuleHandleA(); // A is for ANSI (Not super important, but worth noting)
        /**
            GetModuleHandle Retrieves a module handle for the specified module.
            The module must have been loaded by the calling process.
            The name of the loaded module (either a .dll or .exe file).
            If the file name extension is omitted, the default library
            extension .dll is appended. The file name string can include a
            trailing point character (.) to indicate that the module name has
            no extension.

            We suspect that the string names for such DLLs exist in unexplored
            bytes, and only make a claim that this is what is occurring.
        */
    } // RETURN FROM sub_401260()

    //// CALL
    sub_4012E0() { // CHECK FOR BLACKLISTED FILENAMES / FILEPATHS
        //// CALL
        memset();
        GetModuleFileName();
        PathFindFileName();

        /**
            OBSERVATIONS:
                > [ebp + var_110] & [ebp + var_114] are being used -- They likely represent some system file objects/references
                > [ebp + var_114] is being compared to 06h in a loop. This file object is also getting scanned to locte a given substring.
                    -- Function strstr called to Locate substring on this file reference:
                        Returns a pointer to the first occurrence of str2 in str1, or a null pointer if str2 is not part of str1.
                        The matching process does not include the terminating null-characters, but it stops there.
                > [ebp + var_110] is being compared to 03h in a loop

            NOTE: It's important to note that we are using Virtual Box so, it's
            very possible that VboxTray.exe in the system32 folder could get
            flagged by this malware. Additionally, if we look into the Program Files directory,
            in the Virtual PC Integration Components folder, the VM User Services
            executable (vmusrvc.exe) may also get flagged.
        */
    } // RETURN FROM sub_4012E0()


    //// CALL
    sub_4012A0() { // - CHECKING FOR BLACKLISTED WINDOW NAMES
        //// CALL TO
        FindWindowA();
        /**
            FindWindowA getting called here which retrieves a handle to the
            top-level window whose class name and window name match the
            specified strings. This function does not search child windows.
            This function does not perform a case-sensitive search.

            NOTE: This function can search for windows by name or class
            (for example, OllyDbg, WinDbg). This function can also detect tools
            such as Wireshark or Process Explorer (Refer to SOURCES CITED LIST #1)

            Some examples may include:
                > "OLLYDBG"
                > "PORTMONCLASS"
                > "PROCEXPL"
                > etc.
        */
    } // RETURN FROM sub_4012A0()


    //// CALL
    sub_4013F0() { // --> CHECK FOR USERNAMES
        //// CALL to
        GetUserNameA();
        /**
            (Refer to SOURCES CITED LIST #3):
            Some sandbox solutions and malware analysts show little creativity
            when selecting a username for their analysis machine. Malware takes
            advantage of this lack of creativity and can easily
            test it against a blacklist prior to unpacking itself.

            In our sample below, we see the malware call the function GetUserNameA.
            Here, the malware appears to be checking a dictionary of selected usernames
            to give it a hint as to whether or not its being targeted for analysis.

            Some commonly used user names for malware analysis profiles are
            "SANDBOX" and "CURRENTUSER", among others.
        */
    } // RETURN FROM sub_4013F0()

    //// CALL
    sub_401470() { // --> Detecting if it is in Wine environment via Internal and Legacy APIs
        //// CALL TO
        GetModuleHandleA(lpModuleName);
        GetProcAddress(hModule, lpProcName);
        /**
            WE CAN SEE THAT INPUT PARAMS ARE:
            lpProcName = "wine_get_unix_file_name"
            lpModuleName = "kernel32.dll"

            (See SOURCES CITED #4)
            Many malicious samples try to detect sandbox environment and to do
            so they use an avalanche of tricks that are either generic (checking
            a number of processors) or very specific (VMWare backdoor). One of
            the environments they try to detect using specific tricks is Wine.
            The Wine detection is simple: check if kernel32.dll or ntdll.dll
            exports one of internal Wine APIs. In this case it is checking kernel32.dll
        */
    } // RETURN FROM sub_401470();

    //// CALL
    IsDebuggerPresent(); // -- ANTIDEBUGGING!!!
    /**
        (Refer to Sources Cited List #1 Below)
        IsDebuggerPresent: This function checks a specific flag in the process environment
        block for the field IsDebugged, which will return zero if the process is not running
        in a debugger or a nonzero if a debugger is attached.

        BOOL WINAPI IsDebuggerPresent(void);
    */

    // FINALLY BOOLEAN VALUE [ebp + var_4] == TRUE || [ebp + var_4] == FALSE
    // (This is a boolean check for all of the previous conditional checks)

    ////// Next, there is an instruction to move the true or false value into register AL ////////

    NOTE: We do a unconditional jump to next instruction. This is probably modified by the instructor
    to allow this malware to have some functionality for the purposes of analysis.

    /*****************************************************************************************
        CLAIM #3: IF Affirmative to ANY of the previous conditional checks, we can claim the malware
        is NOT going to be easy to debug as it will attempt to terminate any number of the
        processes which will impede its normal execution.

        NOTE: At this point we've seen A TON of malicious behavior ranging from:

        > Sandbox evasion techniques: To evade sandboxes analysis.
        > Antivirus evasion techniques: To evade detection by antivirus.
        > Anti-debugging techniques: To fool debuggers and avoid analysis.
        > Anti-disassembly: To avoid reverse engineering.
        > Process tricks: To hide the malware processes on the system and stay undetected.
        > Obfuscation and data encoding: To hide data or part of code in the malware.
        > Packers: To protect malware code and add other evasion capabilities (i.e. UPX).

     *****************************************************************************************/

// RETURN TO CALLER WinMain(); -- Line number .text:0040548C

//// GOTO Label loc_40549D
    //// CALL
    CreateMutexA(Mutex Name = "t8"); // Creates or opens a named or unnamed mutex object.
    //// CALL
    GetLastError(); // The return value is the calling thread's last-error code.
    /**
        CreateMutex returns a handle to the mutex that matches the specified name.
        Afterwards, the specimen calls GetLastError to determine whether the handle
        points to the mutex that already existed:

        NOTE: The code then compares the return of the GetLastError function
        to the hex value B7. This value, according to Microsoft, corresponds to the
        symbolic constant ERROR_ALREADY_EXISTS. If the specimen determines that the
        mutex exists, it jumps to the part of the code (at offset 4054BF) that terminates
        its own process, deeming that another infection is not necessary.

        (SOURCES CITED LIST #7)
    */

//// GOTO Label loc_4054C7
    //// CALL
    GetModuleFileNameA();
    DeleteFileA(lpFileName = "Zone.Identifier");
    /**

    The loader will first decrypt its configuration file in its resource section.
    The configuration is an array that defines the execution flow of the malware
    including mutex name. Based on the configuration, it can also delete the
    property of the file being downloaded from the internet by deleting this
    alternate data stream “{filename}:Zone.Identifier” file. This will bypass
    dialog window from browsers implying the file was downloaded from the
    internet. This is an indication that the attackers using drive-by-download
    as a means to install this bot.

        GetModuleFileNameA() Retrieves the fully qualified path for the file
        that contains the specified module. The module must have been loaded
        by the current process.

        NOTE: Zone identifier files are also known as "alternate data stream" (ADS) files,
        since they are only used to describe other files. They have the same filename as the
        original file, followed by a colon and the text "Zone.Identifier." For example, the file
        "update.exe:Zone.Identifier" may be saved along with a downloaded file named "update.exe."

        Windows uses zone identifier files to manage security settings for downloaded files.
        This is a default setting which causes Windows Internet Explorer to prompt the user whenever
        potentially unsafe content is about to download. Note: Web sites that are not mapped
        into other zones automatically fall into this zone.

        Here, by deleting the associated "Zone.Identifier" file for the specified file name,
        the malware is preventing the default URL Policy from alerting the host to any
        suspicious download (i.e. itself).

        (SEE: SOURCES CITED LIST #8)
    */

    Afterwards, the malware pushes three CSIDL folder string values onto the stack (listed below).
    It also pushes a stack variable ([ebp + var_548]) which, from observation, appears
    to be a loop counter that matches the number of folder locations the malware
    intends to traverse for some kind of scan or file manipulation. The folders
    include (See: SOURCES CITED LIST #9 for xRef to common folder variable names):

        >> [ebp + lpSrc] = %windir% ---------> C:\WINDOWS
        >> [ebp + var_430] = %userprofile% ----> C:\Documents and Settings\<user name>
        >> [ebp + var_42C] = %temp% -----------> C:\Documents and Settings\<user name>\Local Settings\Temp
        (NOTE: For our purposes, replace <user name> with "Administrator")

//// GOTO Label loc_40556D
    This label handles the while condition which will perform loop termination if
    the counter variable above (variable ([ebp + var_548])) is >= 3. If it terminates
    the loop, the next branch instruction will be located at label loc_405677.

    We are first interested in what happens at the beginning of the loop, so we
    advance past loop termination to line .text:0040557A.

    //// GOTO next instruction at .text:0040557A
        //// CALL TO
        ExpandEnvironmentStringsA(lpSrc, lpDst, nSize);
        /**
            Expands environment-variable strings and replaces them with the
            values defined for the current user.

            NOTE: MSDN States that the size of the lpSrc (Source) and lpDst (Destination)
            buffers is limited to 32K. We observe that 0x104 is pushed onto the
            stack for three separate buffers. 0x104 is decimal value 260 which,
            when divided by 8 (1 byte) is 32.5, which truncates to 32.

            We know that function memset() is getting called to allocate this buffer space
            for source and destination buffers, and it appears that the malware is
            attempting to duplicate/write data to an executable file "winmgr.exe" to the
            above file locations.

        */

        //// CALL TO
        PathFileExistsA(); // (2 Calls) Line .text:00405628, .text:0040563D
        CreateDirectory(); // Line .text:00405650
        CopyFile(); // Line .text:405666
        /**
            Here, the malware is checking to see if it exists and/or is running as:
            C:\WINDOWS\M-50504508879876012050406030\winmgr.exe

            If not, it is easy to see from the conditional branching and dll
            function calls that it will check to see if it is running in the other
            two locations:

            C:\Documents and Settings\Administrator\M-50504508879876012050406030\winmgr.exe
            C:\Documents and Settings\Administrator\Local Settings\Temp\M-50504508879876012050406030\winmgr.exe

            If it isn't running in any of those locations, the malware ensures
            there is a copy of itself at C:\WINDOWS\M-50504508879876012050406030\winmgr.exe
        */

    //// LOOP TERMINATE -- GOTO Label loc_405677
    Once the while loop counter at label loc_40556D is >= 3. In other words, if it
    has traversed through the following files.

    //// Upon loop termination, GOTO next instruction at Line .text:00405695
        /**
            We now begin the segment of instructions where the malware adds
            itself in the Authorized Application list and in the Firewall Policy
            settings. This is also where it creates Autostarts and disables the
            Windefender service.

            If we cross-reference the .rdata segments, we see the registry values/
            subkeys this sample intends to modify, and from the naming convention,
            we can easily observe what policies/list are being modified.

            .rdata:00407CE8 SYSTEM\\CurrentControlSet\\Services\\SharedAccess\\
                            Parameters\\FirewallPolicy\\StandardProfile\\
                            AuthorizedApplications\\List

            .rdata:00407D60 SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\\

            .rdata:00407D90 Software\\Microsoft\\Windows\\CurrentVersion\\Run\\

            .rdata:00407DC0 SYSTEM\\CurrentControlSet\\services\\WinDefend\\

        */

    The code segment at Line .text:00405695 is where it adds itself in the
    authorized application list.

    The code segment at Line .text:00405760 is where it adds itself to
    configuration settings for each hardware and software item in the computer
    system, corresponding to the currently logged-on user.

    The code segment at Line .text:004057BC is where it adds itself to the
    configuration settings for hardware and software for all users of the computer.

    The code segment at Line .text:00405818 is where it disables the Windefender
    service, an anti-malware--specifically Anti-spyware component of MS Windows.
        > However, the malware should end up skipping this step for our current
          environment because when we check the Registry for HKEY_LOCAL_MACHINE\SYSTEM\
          CurrentControlSet\Services\ , WinDefend is not listed.


        Note that at instruction call sub_403640 at line .text:004058A0, when the
        module needs to end the execution and self-remove, it creates a batch-file
        with pseudo-random name: ...\Local Settings\Temp\.bat


    At label loc_4058AD, and after configuration and checks conducted during the
    previous steps, the sample will begin creating four threads as its main payload routine.

    > 1) A Worm Routine on Removeable Drives
    > 2) A Worm Routine on Network Drives
    > 3) A Worm Routine on Fixed Drives
    > 4) A Backdoor IRC Routine


    This is not a typical worming routine where it will drop a copy of itself
    into target folders or drives. Instead, it will drop a script that will
    download a copy or most likely an updated version of “Trik”. This method
    is another evasion technique employed by the malware. Even if the version
    of the malware is already detected, those infected drives with the
    components of the worm will have a chance to evade the detection.
    (See SOURCES CITED List #13)


    From observation, we can see that the threads get executed by a repeating
    function call to sub_403C60. It pushes the instruction offsets of the
    executing threads in the following order:

        > sub_4023B0
        > sub_4028F0
        > sub_401530
        > sub_405430


Beginning with sub_4023B0, we see several file-related Windows dll and C/C++ library
function calls including:
    GetModuleFileName();
    fopen(); // With String "rb" to indicate reading binary
    fseek();
    ftell();
    GetLogicalDriveStringsA();
    GetDriveType();
    SetErrorMode();
    GetVolumeInformationA();
    GetDriveTypeA();

    In this segment of instructions, this sample proceeds to finding specific drives.
    It targets removable and remote drives except drive “a” or “b”.

    In .text:00402486, we see that it deliberately avoids drive 'a' when it compares
    the path value to 061h (ASCII 'a'). Similarly, in line .text:00402498, it avoids drive 'b'
    when it compares the path value to 062h (ASCII 'b').

    In lines .text:004024C9 and .text:004024ED, we see calls to GetDriveType(lpRootPathName).
    These calls effectively check whether the type of drive is removeable
    (GetDriveType(lpRootPathName) == 2) or if it returned a network drive
    (GetDriveType(lpRootPathName) == 4).

    Depending on the type of drive, it will drop the following files:

        autorun.inf
        DeviceManager.bat
        Manager.bat (if target drive is network drive)
        Manager.js (if target drive is removable)
        .lnk (shortcut file to Manager.js or Manager.bat)


        We corroborated a shortcut request object when we noticed a CLSID value at
        .rdata:00407E34. This CLSID value is recognized as a data structure
        by IDA. The Human-readable way to represent this CLSID value is
        "{00021401-0000-0000-C000-000000000046}". We looked it up manually
        in the registry (HKEY_CLASSES_ROOT\CLSID) by opening regedit and found
        this subkey name by looking at the default value ("shortcut")--A MS Shell
        Link Header.

        Similarly, when we looked up the Handler subkey name specified by IDA as
        "riid", whose hex value was "{000214EE-0000-0000-C000-000000000046}",
        we noticed the shell extension handler object was for a ".lnk" object.
        (See SOURCES CITED List #12 for how we converted these values to
        human-readable format)


        "autorun.inf" will function as an autostart and simply opening the drive
        will execute the malware. It executes Manager.bat or Manager.js which
        will then execute DeviceManager.bat. As an additional evasion technique,
        it adds random strings in between lines of the scripts. Without the randomizer,
        we see the script appear as follows:

        If we look into .rdata:004075B8, we learn that Manager.js simply contains

            var obj = new ActiveXObject(\"WScript.Shell\");
            obj.run(\"DeviceManager.Bat\", 0);


        If we look at .rdata:004076F4, we see that Autorun.inf will contain:

            [autorun]
            icon=%SystemRoot%\system32\SHELL32.dll,4
            action=Open folder to view files
            shellexecute=Manager.bat
            shellexecute=Manager.js
            UseAutoPlay=1


        Furthermore, DeviceManager.bat will contain:

            @echo off
            if exist _ start "" "_"
            tasklist /FI "IMAGENAME eq winmgr.exe" 2>nul | find /I /N "winmgr.exe" >nul
            if "%ERRORLEVEL%"=="0" exit
            if exist _\\DeviceManager\\Manager.exe start_\\DeviceManager\\Manager.exe



Beginning with sub_4028F0:

    >> In the call to sub_402630()

    Aside from worming on removable or network drives, it will also propagates
    a copy of itself into specific folders in fixed drives.

    It targets folders related to web root folders, ftp folders, or other sharing folders.
    It specifically looks for the following sub strings in the folder:

        \\public_html       (.rdata:0040780C)
        \\htdocs            (.rdata:0040781C)
        \\httpdocs          (.rdata:00407824)
        \\wwwroot           (.rdata:00407830)
        \\ftproot           (.rdata:0040783C)
        \\share             (.rdata:00407848)
        \\income            (.rdata:00407850)
        \\upload            (.rdata:00407858)
        \\warez             (.rdata:00407850)

    We see at label loc_402758, [ebp + var_364] represents the counter to
    evaluate these 9 strings.

    If found, for every “.exe” file in that folder, it will replace it with a
    copy of itself. Likewise, for every “.zip” or “.rar” in that folder it will
    add a copy of itself as “README.txt.scr”.



Beginning with sub_401530:

    This is the code segment where the malware actually performs its anti-analysis
    evaluation on the previously mentioned blacklisted processes.

    At label loc_401548, we see that [ebp + var_4] is the loop counter on the five
    Microsoft Security Essenstials processes we mentioned earlier. Furthermore,
    the offset off_409101[ecx*4] is the initial reference to them. We also
    observe that the subsequent call to sub_403140(), which appears to make an
    attempt to terminate these processes.

    At label loc_40157D, we see a loop counter [ebp + var_8] is a loop counter on
    13 processes we indicated earlier, which get passed as parameters to sub_4031F0()
    (a function we mentioned earlier which performs the scans on processes, modules,
    and threads). It appears that if, any number of these processes are discovered,
    this malware will call WSACleanup, which terminates Windows Sockets
    operations for all threads, and then executes the batch command it creates
    in function sub_403640() -- mentioned earlier.



Finally, in sub_405430(),

    We can see that in sub_403F20(), the malware is setting up the Data Structures
    for implementing the WSAStartup function from the Winsock DLL. Specifically,
    we note that this malware is requesting version 2.2 (as noted by the stack
    variable 0x202).

    Trik is an IRC backdoor. The sample we analyzed connects to any of the
    following IRC servers all on port 5050:

        127.181.87.80
        serv5050.de
        serv5051.de
        ouefeeeefhuwuhs.ru
        uwgfubusbbusswf.ru
        oe123uhwugfuuws.ru
        efugusdogdogg.ru
        oksubuszeususur.su

    At label loc_405444, subroutine function sub_405300(), we see the the
    initial steps of TCP Connection Establishment using IP Address 127.181.87.80
    on Port# 5050. Data offset off_4090E8 contains the IP Address string, and word_4090EC
    contains hexadecimal value 0x13BA which is decimal value 5050. If we branch to
    sub_402E90(), in label loc_402EB0, we perform a call to function "socket" with
    the following parameters:
        int af = 2 ==> INET Address Family (IPv4)
        int type = 1 ==> SOCK_STREAM: A socket type that provides sequenced,
                         reliable, two-way, connection-based byte streams
                         with an OOB data transmission mechanism. This socket
                         type uses the Transmission Control Protocol (TCP) for
                         the Internet address family (AF_INET or AF_INET6).
        int protocol = 6 ==> Transmission Control Protocol

    If one of the IRC servers is online, it will issue a NICK containing system
    info and USER command. The USER command contained fixed parameters
    which is always ‘x “” “x” :x’

    The NICK message contains system information including windows version,
    keyboard layout info, and whether the user is admin or not.

    The NICK message is obtained in function call sub_4037F0(), and is subsequently
    sent in function call sub_403F50().

    If successful, it will now wait for specific commands. It specifically
    looks for strings “001”, “433”, and “332” in the message as a signal for
    command. Message retrieval is done in sub_405200() at line.text:004053A4.
    When the bot receives the message, it will eventually arrive at label loc_4052BD
    where it will make a call to sub_404FF0(). This is where it receives its commands
    through the IRC Channel.

        Command 001 means it will ask the bot to join to a specific channel.
        This command is pushed onto the stack for later evaluation at line
        .text:0040501D.

        Command 433 instructs the bot to send system information. This command is
        checked at label loc_405111.

        Command 332 contains additional sub commands. This command is checked at
        label loc_4051B2 It can instruct the bot to:
            Remove itself from the system
            Send more system information
            Download and execute files


    It also seeks specific countries by getting the geolocation of the
    infected user through http://api.wipmania.com/. It will only download
    from specific list of countries hardcoded in its body. The list contains
    only countries from Americas and European countries.


}
