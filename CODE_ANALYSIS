WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd) {
    HANDLE hKey = 65Ch; // (uExitCode) Line 405473
    DWORD dwMilliseconds = 0x03E8 // Time = 1000 msec -- Line 405479

    // This is called to buy the malware time to perform some time-consuming conditional checks
    Sleep(dwMilliseconds); // CALL Sleep() for 1000 msec = 1 sec -- Line 40547E

    // CALL
    sub_4014B0(); // -- !! SANDBOX EVASION, ANTIVIRUS EVASION, & ANTI-DEBUGGING !!
        //// CALL
        sub_401000();
            //// CALL
            CreateFileA(); // using the following parameters
            /**
                dwCreationDisposition = 3 ==> OPEN EXISTING FILE
                dwDesiredAccess = 0 ==> Allows the application to query device attributes without accessing a device
                FileName = \\\\.\\PhysicalDrive0 ==> Opens the first physical drive. Hard Disk Numbers Start at 0.

                NOTE: Windows Server 2003 and Windows XP:  Direct access to the
                disk or to a volume is not restricted in this manner.
                You can use the CreateFile function to open a physical disk
                drive or a volume, which returns a direct access storage device (DASD)
                handle that can be used with the DeviceIoControl function. This enables you
                to access the disk or volume directly, for example such disk metadata as
                the partition table.
            */
            //// CALL function
            DeviceIoControl(); // using the following parameter -- Line 4010EA
                    /**
                        dwIoControlCode = 0x002D1400 ==> IOCTL_STORAGE_QUERY_PROPERTY

                        IO Control Code Reference (See SOURCES CITED #2 Below):

                        FROM MSDN:
                        Windows applications can use this control code to return
                        the properties of a storage device or adapter. The request
                        indicates the kind of information to retrieve, such as the
                        inquiry data for a device or the capabilities and limitations
                        of an adapter. IOCTL_STORAGE_QUERY_PROPERTY CAN ALSO BE USED
                        TO DETERMINE WHETHER THE PORT DRIVER SUPPORTS A PARTICULAR
                        PROPERY OR WHICH FIELDS IN THE PROPERTY DESCRIPTOR CAN BE
                        MODIFIED WITH A CHANGE PROPERTY REQUEST.
                    */
                /**
                    OBSERVATIONS: String "qemu" is a local function variable.
                    QEMU is an open-source virtualization OS emulator.

                    CLAIM 1: the two other local variables next to it (unk_407448, and unk_407450)
                    are strings "vmware" and "vbox", or similar string names for virtual machine tools.
                    We can infer that the malware is checking registry artifacts see if it is running
                    inside a virtual machine. This is evident from the fact that at this point it has
                    attempted to read the primary hard disk to perform a sequential scan which will
                    ascertain if it is running in a vm.

                    COMMON STRINGS TO BE SEARCHED:
                        qm00001
                        virtual
                        array
                        vbox
                        vmware
                        00000000000000000001
                */
    } //// RETURN FROM sub_4014B0();

    //// CALL
    sub_401220() {
        //// CALL to
        sub_4031F0(); // --> CreateToolhelp32Snapshot with the following parameters:
            //// CALL to
            CreateToolhelp32Snapshot();
            /**
                CreateToolhelp32Snapshot Takes a snapshot of the specified processes,
                as well as the heaps, modules, and threads used by these processes.

                dwFlags = 0x0000000F ==> (TH32CS_SNAPALL -- SEE SOURCES CITED LIST #5)
                Includes all processes and threads in the system, plus the heaps and
                modules of the process specified in th32ProcessID.
                Equivalent to specifying the TH32CS_SNAPHEAPLIST, TH32CS_SNAPMODULE,
                TH32CS_SNAPPROCESS, and TH32CS_SNAPTHREAD values combined using an OR operation ('|').

                th32ProcessID = 0 ==>
                The process identifier of the process to be included in the snapshot.
                This parameter can be zero to indicate the current process.
                This parameter is used when the TH32CS_SNAPHEAPLIST, TH32CS_SNAPMODULE, T
                H32CS_SNAPMODULE32, or TH32CS_SNAPALL value is specified. Otherwise,
                it is ignored and all processes are included in the snapshot.

                NOTE: Process discovery: Malware may be able to detect whether
                there are any running processes related to a sandbox. For example,
                processes such as VmwareService.exe can be easily detected with the
                CreateToolHelp32Snapshot API, to get a snapshot of the current
                running processes, and then list each process of the snapshot with
                the APIs Process32First and Process32Next.
            */
                //// CALL
                Process32First(); // which Retrieves information about the first process encountered in a system snapshot.
                    //// LOOP CALL
                    Process32Next(); // which Retrieves information about the next process recorded in a system snapshot.
    } // RETURN FROM sub_401220


    //// CALL
    sub_401260() {
        ////CALL TO
        GetModuleHandleA(); // A is for ANSI (Not super important, but worth noting)
        /**
            GetModuleHandle Retrieves a module handle for the specified module.
            The module must have been loaded by the calling process.
            The name of the loaded module (either a .dll or .exe file).
            If the file name extension is omitted, the default library
            extension .dll is appended. The file name string can include a
            trailing point character (.) to indicate that the module name has
            no extension.

            NOTE: Some kind of conditional check on several modules are being
            done... We possibly need to find out what these modules are.
        */
    } // RETURN FROM sub_401260()

    //// CALL
    sub_4012E0() {
        //// CALL
        memset(); // The malware is definitely modifying buffers (FROM MSDN: "Sets buffers to a specified character.")
        GetModuleFileName();
        PathFindFileName();

        /**
            OBSERVATIONS:
                > [ebp + var_110] & [ebp + var_114] are being used -- They likely represent some system file objects/references
                > [ebp + var_114] is being compared to 06h in a loop. This file object is also getting scanned to locte a given substring.
                    -- Function strstr called to Locate substring on this file reference:
                        Returns a pointer to the first occurrence of str2 in str1, or a null pointer if str2 is not part of str1.
                        The matching process does not include the terminating null-characters, but it stops there.
                > [ebp + var_110] is being compared to 03h in a loop

            CLAIM #2: Somewhere in here, we suspect the malware is checking for VM Drivers, VM DLLs, and/or Registry Detection:

                (FROM SOURCES CITED LIST #1 below)
                Registry detection: Virtual environments create registry keys on the system that can be detected by malware.
                Following we see an incomplete list of the registry keys that malware can check:

                “HARDWARE\\DEVICEMAP\\Scsi\\Scsi Port 0\\Scsi Bus 0\\Target Id 0\\Logical Unit Id 0”
                “SOFTWARE\\VMware, Inc.\\VMware Tools”
                “HARDWARE\\Description\\System”
                “SOFTWARE\\Oracle\\VirtualBox Guest Additions”
                “SYSTEM\\ControlSet001\\Services\\Disk\\Enum”
                “HARDWARE\\ACPI\\DSDT\\VBOX__”
                “HARDWARE\\ACPI\\FADT\\VBOX__”
                “HARDWARE\\ACPI\\RSDT\\VBOX__”
                “SYSTEM\\ControlSet001\\Services\\VBoxGuest”
                “SYSTEM\\ControlSet001\\Services\\VBoxMouse”
                “SYSTEM\\ControlSet001\\Services\\VBoxService”
                “SYSTEM\\ControlSet001\\Services\\VBoxSF”
                “SYSTEM\\ControlSet001\\Services\\VBoxVideo”
        */
    } // RETURN FROM sub_4012E0()


    //// CALL
    sub_4012A0() { // - Start of Anti-Debugging routine
        //// CALL TO
        FindWindowA();
        /**
            FindWindowA getting called here which retrieves a handle to the
            top-level window whose class name and window name match the
            specified strings. This function does not search child windows.
            This function does not perform a case-sensitive search.

            NOTE: This function can search for windows by name or class
            (for example, OllyDbg, WinDbg). This function can also detect tools
            such as Wireshark or Process Explorer (Refer to SOURCES CITED LIST #1)
        */
    } // RETURN FROM sub_4012A0()


    //// CALL
    sub_4013F0() { // --> Additional Sandbox Detection
        //// CALL to
        GetUserNameA();
        /**
            (Refer to SOURCES CITED LIST #3):
            Some sandbox solutions and malware analysts show little creativity
            when selecting a username for their analysis machine. Malware takes
            advantage of this lack of creativity and can easily
            test it against a blacklist prior to unpacking itself.

            In our sample below, we see a malware call the GetUserNameA:

            //////////////////////////// NOT CONFIRMED YET ///////////////////////////////////////////////////////////
            At first glance it seems like a legitimate piece of code, but when inspecting the series of conditional
            jumps closely, we see that it compares the retrieved value with the hardcoded string "SANDBOX".
            If this is indeed the username – the malware terminates immediately.
            //////////////////////////////////////////////////////////////////////////////////////////////////////////
        */
    } // RETURN FROM sub_4013F0()


    //// CALL
    sub_401470() { // --> Detecting if it is in Wine environment via Internal and Legacy APIs
        //// CALL TO
        GetModuleHandleA(lpModuleName);
        GetProcAddress(hModule, lpProcName);
        /**
            WE CAN SEE THAT INPUT PARAMS ARE:
            lpProcName = "wine_get_unix_file_name"
            lpModuleName = "kernel32.dll"

            (See SOURCES CITED #4)
            Many malicious samples try to detect sandbox environment and to do
            so they use an avalanche of tricks that are either generic (checking
            a number of processors) or very specific (VMWare backdoor). One of
            the environments they try to detect using specific tricks is Wine.
            The Wine detection is simple: check if kernel32.dll or ntdll.dll
            exports one of internal Wine APIs. In this case it is checking kernel32.dll
        */
    } // RETURN FROM sub_401470();

    //// CALL
    IsDebuggerPresent(); // -- ANTIDEBUGGING!!!
    /**
        (Refer to Sources Cited List #1 Below)
        IsDebuggerPresent: This function checks a specific flag in the process environment
        block for the field IsDebugged, which will return zero if the process is not running
        in a debugger or a nonzero if a debugger is attached.

        BOOL WINAPI IsDebuggerPresent(void);
    */

    // FINALLY BOOLEAN VALUE [ebp + var_4] == TRUE || [ebp + var_4] == FALSE
    // (This is a boolean check for all of the previous conditional checks)

    ////// Next, there is an instruction to move the true or false value into register AL ////////

    NOTE: We do a unconditional jump to next instruction. This is probably modified by the instructor
    to allow this malware to have some functionality for the purposes of analysis.

    /*****************************************************************************************
        CLAIM #3: IF Affirmative to ANY of the previous conditional checks, we can claim the malware
        is NOT going to be easy to debug or be able to behave the way it really wants to.

        NOTE: At this point we've seen A TON of malicious behavior ranging from:

        > Sandbox evasion techniques: To evade sandboxes analysis.
        > Antivirus evasion techniques: To evade detection by antivirus.
        > Anti-debugging techniques: To fool debuggers and avoid analysis.
        > Anti-disassembly: To avoid reverse engineering.
        > Process tricks: To hide the malware processes on the system and stay undetected.
        > Obfuscation and data encoding: To hide data or part of code in the malware.
        > Packers: To protect malware code and add other evasion capabilities (i.e. UPX).

     *****************************************************************************************/

// RETURN TO CALLER WinMain(); -- Line number .text:0040548C

//// GOTO Label loc_40549D
    //// CALL
    CreateMutexA(Mutex Name = "t8"); // Creates or opens a named or unnamed mutex object.
    //// CALL
    GetLastError(); // The return value is the calling thread's last-error code.
    /**
        CreateMutex returns a handle to the mutex that matches the specified name.
        Afterwards, the specimen calls GetLastError to determine whether the handle
        points to the mutex that already existed:

        NOTE: The code then compares the return of the GetLastError function
        to the hex value B7. This value, according to Microsoft, corresponds to the
        symbolic constant ERROR_ALREADY_EXISTS. If the specimen determines that the
        mutex exists, it jumps to the part of the code (at offset 4054BF) that terminates
        its own process, deeming that another infection is not necessary.

        (SOURCES CITED LIST #7)
    */

//// GOTO Label loc_4054C7
    //// CALL
    GetModuleFileNameA();
    DeleteFileA(lpFileName = "Zone.Identifier");
    /**
        GetModuleFileNameA() Retrieves the fully qualified path for the file
        that contains the specified module. The module must have been loaded
        by the current process.

        NOTE: Zone identifier files are also known as "alternate data stream" (ADS) files,
        since they are only used to describe other files. They have the same filename as the
        original file, followed by a colon and the text "Zone.Identifier." For example, the file
        "update.exe:Zone.Identifier" may be saved along with a downloaded file named "update.exe."

        Windows uses zone identifier files to manage security settings for downloaded files.
        This is a default setting which causes Windows Internet Explorer to prompt the user whenever
        potentially unsafe content is about to download. Note: Web sites that are not mapped
        into other zones automatically fall into this zone.

        Here, by deleting the associated "Zone.Identifier" file for the specified file name,
        the malware is preventing the default URL Policy from alerting the host to any
        suspicious download (i.e. itself).

        (SEE: SOURCES CITED LIST #8)
    */

    Afterwards, the malware pushes three CSIDL folder string values onto the stack (listed below).
    It also pushes a stack variable ([ebp + var_548]) which, from observation, appears
    to be a loop counter that matches the number of folder locations the malware
    intends to traverse for some kind of scan or file manipulation. The folders
    include (See: SOURCES CITED LIST #9 for xRef to common folder variable names):

        >> [ebp + lpSrc] = %windir% ---------> C:\WINDOWS
        >> [ebp + var_430] = %userprofile% ----> C:\Documents and Settings\<user name>
        >> [ebp + var_42C] = %temp% -----------> C:\Documents and Settings\<user name>\Local Settings\Temp
        (NOTE: For our purposes, replace <user name> with "Administrator")

//// GOTO Label loc_40556D
    This label handles the while condition which will perform loop termination if
    the counter variable above (variable ([ebp + var_548])) is >= 3. If it terminates
    the loop, the next branch instruction will be located at label loc_405677.

    We are first interested in what happens at the beginning of the loop, so we
    advance past loop termination to line .text:0040557A.

    //// GOTO next instruction at .text:0040557A
        //// CALL TO
        ExpandEnvironmentStringsA(lpSrc, lpDst, nSize);
        /**
            Expands environment-variable strings and replaces them with the
            values defined for the current user.

            NOTE: MSDN States that the size of the lpSrc (Source) and lpDst (Destination)
            buffers is limited to 32K. We observe that 0x104 is pushed onto the
            stack for three separate buffers. 0x104 is decimal value 260 which,
            when divided by 8 (1 byte) is 32.5, which truncates to 32.

            We know that function memset() is getting called to allocate this buffer space
            for source and destination buffers, and it appears that the malware is
            attempting to duplicate/write data to an executable file "winmgr.exe" to the
            above file locations.

        */

        //// CALL TO
        PathFileExistsA(); // (2 Calls) Line .text:00405628, .text:0040563D
        CreateDirectory(); // Line .text:00405650
        CopyFile(); // Line .text:405666
        /**
            Here, the malware is checking to see if it exists and/or is running in:
            C:\WINDOWS\M-50504508879876012050406030\winmgr.exe

            If so, it is easy to see from the conditional branching and dll
            function calls that it will ensure a copy also exists in the other two
            specified file locations

            C:\Documents and Settings\Administrator\M-50504508879876012050406030\winmgr.exe
            C:\Documents and Settings\Administrator\Local Settings\Temp\M-50504508879876012050406030\winmgr.exe
        */

    //// LOOP TERMINATE -- GOTO Label loc_405677
    Once the while loop counter at label loc_40556D is >= 3. In other words, if it
    has traversed through the following files.

    //// Upon loop termination, GOTO next instruction at Line .text:00405695
        /**
            We now begin the segment of instructions where the malware adds
            itself in the Authorized Application list and in the Firewall Policy
            settings. This is also where it creates Autostarts and disables the
            Windefender service.

            If we cross-reference the .rdata segments, we see the registry values/
            subkeys this sample intends to modify, and from the naming convention,
            we can easily observe what policies/list are being modified.

            .rdata:00407CE8 SYSTEM\\CurrentControlSet\\Services\\SharedAccess\\
                            Parameters\\FirewallPolicy\\StandardProfile\\
                            AuthorizedApplications\\List

            .rdata:00407D60 SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\\

            .rdata:00407D90 Software\\Microsoft\\Windows\\CurrentVersion\\Run\\

            .rdata:00407DC0 SYSTEM\\CurrentControlSet\\services\\WinDefend\\

        */

        






}
